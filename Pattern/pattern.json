{
	 "patterns": [
    {
      "name": "Anti-Corruption Layer",
      "description": "Implement a fa√ßade or adapter layer between different subsystems that don't share the same semantics. This layer translates requests that one subsystem makes to the other subsystem. Use this pattern to ensure that an application's design is not limited by dependencies on outside subsystems.",
      "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/anti-corruption-layer",
      "tags": [
		{
          "tagName": "Domain",
          "tagValue": "Microservice"
        },
        {
          "tagName": "Integration",
          "tagValue": "External Systems"
        },
        {
          "tagName": "Architectural Strategy",
          "tagValue": "Isolation"
        },
        {
          "tagName": "Scope",
          "tagValue": "External"
        },
        {
          "tagName": "Category",
          "tagValue": "Integration"
        },
        {
          "tagName": "Problem",
          "tagValue": "Coupling"
        },
        {
          "tagName": "Cost",
          "tagValue": "Latency"
        },
        {
          "tagName": "Benefit",
          "tagValue": "Decoupling"
        },
        {
          "tagName": "Role",
          "tagValue": "Adaptor"
        },
        {
          "tagName": "Development Paradigm",
          "tagValue": "Domain-Driven Design (DDD)"
        }
      ]
    },
    {
      "name": "Choreography",
      "description": "Have each component of the system participate in the decision-making process about the workflow of a business transaction, instead of relying on a central point of control.",
      "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/choreography",
      "tags": [
		{
          "tagName": "Domain",
          "tagValue": "Microservice"
        },
        {
          "tagName": "Category",
          "tagValue": "Communication"
        },
        {
          "tagName": "Scope",
          "tagValue": "External"
        },
        {
          "tagName": "Problem",
          "tagValue": "Coupling"
        },
        {
          "tagName": "Communication Style",
          "tagValue": "Asynchronous"
        },
        {
          "tagName": "Cost",
          "tagValue": "Chattiness"
        },
        {
          "tagName": "Benefit",
          "tagValue": "Throughput"
        },
        {
          "tagName": "Governance",
          "tagValue": "Decentralized"
        },
        {
          "tagName": "Benefit",
          "tagValue": "Scalable Communication"
        },
        {
          "tagName": "Cost",
          "tagValue": "Complex Communication"
        },
        {
          "tagName": "Development Paradigm",
          "tagValue": "Event-Driven Architecture"
        }
      ]
    },
    {
      "name": "Command-Query Responsibility Segregation",
      "description": "separates read and update operations for a data store. Implementing CQRS in your application can maximize its performance, scalability, and security. The flexibility created by migrating to CQRS allows a system to better evolve over time and prevents update commands from causing merge conflicts at the domain level.",
      "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/cqrs",
      "tags": [
		{
          "tagName": "Domain",
          "tagValue": "Microservice"
        },
        {
          "tagName": "Category",
          "tagValue": "Query"
        },
        {
          "tagName": "Architectural Strategy",
          "tagValue": "Specialization"
        },
        {
          "tagName": "Problem",
          "tagValue": "Distributed query"
        },
        {
          "tagName": "Scope",
          "tagValue": "External"
        },
        {
          "tagName": "Cost",
          "tagValue": "Eventual consistency"
        },
        {
          "tagName": "Benefit",
          "tagValue": "Performance"
        },
        {
          "tagName": "Communication Style",
          "tagValue": "Asynchronous"
        },
        {
          "tagName": "Testing",
          "tagValue": "Command and Query Testing"
        },
        {
          "tagName": "Scaling",
          "tagValue": "Horizontal and Data Partitioning Scaling"
        },
        {
          "tagName": "Role",
          "tagValue": "Aggregator"
        },
        {
          "tagName": "Data Ownership",
          "tagValue": "Service-Specific Data Storage"
        },
        {
          "tagName": "Development Paradigm",
          "tagValue": "Event-Driven Architecture"
        }
      ]
    },
    {
      "name": "Decompose by Subdomain",
      "description": "Each microservice must have its own responsibilities, and a poorly-defined decomposition can cause unnecessary coupling. So, define the boundaries of your microservices using DDD's subdomain concept.",
      "url": "https://microservices.io/patterns/decomposition/decompose-by-subdomain.html",
      "tags": [
	    {
          "tagName": "Domain",
          "tagValue": "Microservice"
        },
        {
          "tagName": "Category",
          "tagValue": "Decomposition"
        },
        {
          "tagName": "Problem",
          "tagValue": "Defining Boundaries"
        },
        {
          "tagName": "Architectural Strategy",
          "tagValue": "Decomposition"
        },
        {
          "tagName": "Scope",
          "tagValue": "External"
        },
        {
          "tagName": "Development Paradigm",
          "tagValue": "Domain-Driven Design (DDD)"
        },
        {
          "tagName": "Testing",
          "tagValue": "Contract Testing"
        },
        {
          "tagName": "Scaling",
          "tagValue": "Horizontal Scaling"
        },
        {
          "tagName": "Data Ownership",
          "tagValue": "Domain-Specific Data Storage"
        }
      ]
    },
    {
      "name": "Event Sourcing",
      "description": "Instead of storing just the current state of the data in a domain, use an append-only store to record the full series of actions taken on that data. The store acts as the system of record and can be used to materialize the domain objects.",
      "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/event-sourcing",
      "tags": [
		{
          "tagName": "Domain",
          "tagValue": "Microservice"
        },
        {
          "tagName": "Category",
          "tagValue": "Data Management"
        },
        {
          "tagName": "Scope",
          "tagValue": "External and Internal"
        },
        {
          "tagName": "Problem",
          "tagValue": "Temporal Inconsistency"
        },
        {
          "tagName": "Cost",
          "tagValue": "Performance"
        },
        {
          "tagName": "Benefit",
          "tagValue": "Consistency"
        },
        {
          "tagName": "Scaling",
          "tagValue": "Horizontal Scaling"
        },
        {
          "tagName": "Testing",
          "tagValue": "Event Replay Testing"
        },
        {
          "tagName": "Consistency",
          "tagValue": "Eventual Consistency"
        },
        {
          "tagName": "Communication Style",
          "tagValue": "Asynchronous"
        },
        {
          "tagName": "Development Paradigm",
          "tagValue": "Event-Driven Architecture"
        }
      ]
    },
    {
      "name": "Gatekeeper",
      "description": "The Gatekeeper pattern involves using an intermediary service or component to control and manage access to resources or functionality in a distributed system, enhancing security and enforcing policies.",
      "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/gatekeeper",
      "tags": [
		{
          "tagName": "Domain",
          "tagValue": "Microservice"
        },
        {
          "tagName": "Category",
          "tagValue": "Security"
        },
        {
          "tagName": "Governance",
          "tagValue": "Centralized"
        },
        {
          "tagName": "Scope",
          "tagValue": "External"
        },
        {
          "tagName": "Scaling",
          "tagValue": "Horizontal Scaling"
        },
        {
          "tagName": "Problem",
          "tagValue": "Centralized security"
        },
        {
          "tagName": "Testing",
          "tagValue": "Security Testing"
        },
        {
          "tagName": "Benefit",
          "tagValue": "Centralized Security Management"
        },
        {
          "tagName": "Cost",
          "tagValue": "Potential Single Point of Failure"
        },
        {
          "tagName": "Role",
          "tagValue": "Proxy"
        },
        {
          "tagName": "Architectural Strategy",
          "tagValue": "Proxying"
        },
        {
          "tagName": "Service Composition",
          "tagValue": "Union of Services"
        }
      ]
    },
    {
      "name": "Gateway Aggregation",
      "description": "The Gateway Aggregation pattern involves consolidating multiple requests from clients into a single request to reduce network overhead and improve efficiency in a microservices architecture.",
      "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/gateway-aggregation",
      "tags": [
		{
          "tagName": "Domain",
          "tagValue": "Microservice"
        },
        {
          "tagName": "Category",
          "tagValue": "Query"
        },
        {
          "tagName": "Service Composition",
          "tagValue": "Aggregated Services"
        },
        {
          "tagName": "Scope",
          "tagValue": "External"
        },
        {
          "tagName": "Testing",
          "tagValue": "End-to-End Testing"
        },
        {
          "tagName": "Communication Style",
          "tagValue": "Synchronous"
        },
        {
          "tagName": "Benefit",
          "tagValue": "Simplified Integration and Composition"
        },
        {
          "tagName": "Cost",
          "tagValue": "Increased Complexity in Gateway Logic"
        },
        {
          "tagName": "Problem",
          "tagValue": "Distributed Query"
        },
        {
          "tagName": "Role",
          "tagValue": "Aggregator"
        },
        {
          "tagName": "Architectural Strategy",
          "tagValue": "Proxying"
        },
        {
          "tagName": "Consistency",
          "tagValue": "Strong consistency"
        },
        {
          "tagName": "Scaling",
          "tagValue": "Data Partitioning"
        }
      ]
    },
    {
      "name": "Gateway Routing",
      "description": "The Gateway Routing pattern is a design approach where a centralized gateway service directs client requests to appropriate microservices based on predefined routing rules, facilitating dynamic and efficient traffic management in a distributed system.",
      "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/gateway-routing",
      "tags": [
		{
          "tagName": "Domain",
          "tagValue": "Microservice"
        },
        {
          "tagName": "Category",
          "tagValue": "Integration"
        },
        {
          "tagName": "Integration",
          "tagValue": "External Clients"
        },
        {
          "tagName": "Governance",
          "tagValue": "Centralized"
        },
        {
          "tagName": "Scope",
          "tagValue": "External"
        },
        {
          "tagName": "Benefit",
          "tagValue": "Centralized Routing Control"
        },
        {
          "tagName": "Cost",
          "tagValue": "Dependency on Gateway for Routing"
        },
        {
          "tagName": "Problem",
          "tagValue": "Distributed Services"
        },
        {
          "tagName": "Role",
          "tagValue": "Proxy"
        },
        {
          "tagName": "Architectural Strategy",
          "tagValue": "Proxying"
        },
        {
          "tagName": "Service Composition",
          "tagValue": "Union of Services"
        }
      ]
    },
    {
      "name": "Messaging",
      "description": "The Messaging pattern involves communication between software components through messages, enhancing decoupling, scalability, and flexibility in distributed systems.",
      "url": "https://microservices.io/patterns/communication-style/messaging.html",
      "tags": [
	  	{
          "tagName": "Domain",
          "tagValue": "Microservice"
        },
        {
          "tagName": "Category",
          "tagValue": "Communication"
        },
        {
          "tagName": "Development Paradigm",
          "tagValue": "Event-Driven Architecture"
        },
        {
          "tagName": "Communication Style",
          "tagValue": "Asynchronous"
        },
        {
          "tagName": "Scope",
          "tagValue": "External and Internal"
        },
        {
          "tagName": "Testing",
          "tagValue": "Message Processing Testing"
        },
        {
          "tagName": "Benefit",
          "tagValue": "Responsiveness"
        },
        {
          "tagName": "Cost",
          "tagValue": "Complex Error Handling"
        },
        {
          "tagName": "Problem",
          "tagValue": "Coupled communication"
        }
      ]
    },
    {
      "name": "Queue-based Load Levelling",
      "description": "The Queue-based Load Levelling pattern involves using queues to distribute processing tasks evenly across multiple consumers, optimizing resource utilization and improving system stability in a distributed environment",
      "url": "https://learn.microsoft.com/en-us/azure/architecture/patterns/queue-based-load-leveling",
      "tags": [
		{
          "tagName": "Domain",
          "tagValue": "Microservice"
        },
        {
          "tagName": "Category",
          "tagValue": "Scalability"
        },
        {
          "tagName": "Scaling",
          "tagValue": "Horizontal Scaling"
        },
        {
          "tagName": "Scope",
          "tagValue": "External"
        },
        {
          "tagName": "Benefit",
          "tagValue": "Scalable Distribution"
        },
        {
          "tagName": "Cost",
          "tagValue": "Latency"
        },
        {
          "tagName": "Problem",
          "tagValue": "Workload Distribution"
        },
        {
          "tagName": "Architectural Strategy",
          "tagValue": "Proxying"
        },
        {
          "tagName": "Role",
          "tagValue": "Proxy"
        }
      ]
    },
    {
      "name": "Database per Service",
      "description": "",
      "url": "https://microservices.io/patterns/data/database-per-service.html",
      "tags": [
		{
          "tagName": "Domain",
          "tagValue": "Microservice"
        },
        {
          "tagName": "Category",
          "tagValue": "Data Management"
        },
        {
          "tagName": "Governance",
          "tagValue": "Decentralized"
        },
        {
          "tagName": "Benefit",
          "tagValue": "Isolated Data Management"
        },
        {
          "tagName": "Cost",
          "tagValue": "Increased Complexity in Data Consistency"
        },
        {
          "tagName": "Problem",
          "tagValue": "Shared Data Access"
        },
        {
          "tagName": "Data Ownership",
          "tagValue": "Service-Specific Data Storage"
        },
        {
          "tagName": "Scaling",
          "tagValue": "Data Partitioning"
        },
        {
          "tagName": "Development Paradigm",
          "tagValue": "Domain-Driven Design (DDD)"
        }
      ]
    },
    {
      "name": "Server Side Discovery",
      "description": "The Server-Side Discovery pattern involves a central service registry where servers register their availability, facilitating dynamic and efficient client-server communication in a distributed system.",
      "url": "https://microservices.io/patterns/server-side-discovery.html",
      "tags": [
		{
          "tagName": "Domain",
          "tagValue": "Microservice"
        },
        {
          "tagName": "Category",
          "tagValue": "Integration"
        },
        {
          "tagName": "Integration",
          "tagValue": "Internal Services"
        },
        {
          "tagName": "Benefit",
          "tagValue": "Dynamic Service Configuration"
        },
        {
          "tagName": "Cost",
          "tagValue": "Dependency on Discovery Mechanism"
        },
        {
          "tagName": "Problem",
          "tagValue": "Dynamic Service Location"
        },
        {
          "tagName": "Role",
          "tagValue": "Service Locator"
        }
      ]
    }
  ]
}
	
	
	